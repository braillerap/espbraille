import sys
import os
import json
import glob
import fnmatch
import mimetypes
import pathlib

NBCOL = 8
display = False

def pathtovar (path):
    vname = "dat_" + os.path.basename(path)
    vname = vname.replace(".", "__")
    vname = vname.replace("-", "__")
    return vname

def pathtoweb (path):
    wpath = path.replace("\\", "/")
    return wpath

def write_header (stream, filename):
    stream.write ("// Autogenerated file\n")
    stream.write ("// Do not manually modify\n")
    stream.write ("// file:{0}\n".format(filename))
    stream.write ("\n")
    stream.write ("\n")

def write_start (stream, filename):    
    stream.write ("#include <stdio.h>\n")
    stream.write ("#include <stdlib.h>\n")

    #stream.write ("#ifdef __EMSCRIPTEN__\n")
    #stream.write ("#include \"emscripten.h\"\n")
    #stream.write ("#define EXPORT_CALL EMSCRIPTEN_KEEPALIVE\n")
    #stream.write ("#endif\n")
    stream.write ("\n")

def getDisplayName (path):
    display = ""
    with open(path,"rt") as fin:
        while True:
            line = fin.readline()
            if not line:
                break
            if line.find ("display-name") >= 0:
                field = line.split (':')
                if len (field) > 1:
                    display = field[1].strip ()
    return display            

def GetTag (path, stag):
    tag = ""
    with open(path,"rt") as fin:
        while True:
            line = fin.readline()
            if not line:
                break
            if line.find (stag) >= 0:
                field = line.split (':')
                
                if len (field) > 1:
                    tag = field[1].strip ()
    return tag            

def file2c (pathfrom, pathto, varname, filename, mime):
    with open(pathfrom,"rb") as fin:
        data = fin.read ()
    
    with open (pathto, "w") as fout:
        write_header(fout, filename)
        write_start(fout, filename)

        fout.write ("const uint8_t {0}[]".format(varname))
        fout.write ("={\n")
        size = len(data)
        col = 0
        for i in range (size):
            fout.write ("0x{:02x}".format (data[i]))
            if i != size - 1:
                if i % NBCOL == 0 and  i > 0:
                    fout.write (",\n")
                else:
                    fout.write (",")
            else:
                fout.write ("\n")
        fout.write ("};\n")
        fout.write ("const size_t {0}_size=sizeof({0});\n".format(varname))

def build_database (generated, header, implement, dbname, dbtype, dbinfo_type, config):
    
    print ("build_database :", implement)    
    with open (implement, "w") as fout:
        write_header(fout, implement)
        write_start(fout, implement)
        fout.write ("#include \"{0}\"\n".format (os.path.basename(header)))
        fout.write ("\n")
        fout.write ("\n")

        for f in generated:
            fout.write ("const extern uint8_t {1}[];\n".format(dbtype, f["var"]))                
            fout.write ("const extern size_t {0};\n".format(f["var"]+"_size"))                

        fout.write ("{0} {1}[] = ".format(dbtype, dbname))
        fout.write ("{\n")
        
        for f in generated:
            fout.write ("\t{ ")    
            fout.write ("\"{0}\",".format(f["filename"]))
            fout.write ("{0},".format(f["var"]))                
            fout.write (" &{0}".format(f["var"]+"_size"))                
            fout.write (" },\n")    
        fout.write ("};\n")
        fout.write ("\n")
        fout.write ("\n")

        fout.write ("{0} {1}[] = ".format(dbinfo_type, dbname+"_info" ))
        fout.write ("{\n")
        filters = config['db_table_filter']
        count = 0
        for f in generated:
            for filter in filters:
                if fnmatch.fnmatch(f["filename"], filter):
                    path = f["path"]
                    displayname = "" #getDisplayName(f["path"])
                    language = "" #GetTag (f["path"], "#+language")
                    region = "" #GetTag (f["path"], "#+region")
                    ltype = "" #GetTag (f["path"], "#+type")
                    mode = 0

                    #if ltype == "computer":
                    #    mode += 1

                    if len(path) > 0:
                        #print ("{:10} {:8} {:8} {:25} {}".format(language, region, ltype, f["filename"], displayname))
                        fout.write ("\t{ ")    
                        fout.write ("\"{0}\",".format(f["filename"]))
                        fout.write ("\"/{0}\",".format(path))
                        fout.write ("\"{0}\" ".format(f["mimetype"][0]))
                        fout.write (" },\n")   
                        count += 1 
                    break
        fout.write ("};\n")
        fout.write ("\n")
        fout.write ("\n")
        if display:
            fout.write ("{0} {1}[] = ".format(dbinfo_type, dbname+"_display" ))
            fout.write ("{\n")
            filters = config['db_display_filter']
            countdisplay = 0
            for f in generated:
                for filter in filters:
                    if fnmatch.fnmatch(f["filename"], filter):
                        
                        

                        
                        if len(displayname) > 0:
                            print ("{}".format(f["filename"]))
                            fout.write ("\t{ ")    
                            fout.write ("\"{0}\",".format(f["filename"]))
                            fout.write ("\"\",")
                            fout.write ("\"\",")
                            fout.write ("\"\",")
                            fout.write ("0x0")
                            fout.write (" },\n")   
                            countdisplay += 1 
                        break
            fout.write ("};\n")
            fout.write ("\n")
            fout.write ("\n")

        print (count, "standards")

        with open (header, "w") as fout:
            write_header(fout, header)
            fout.write ("\n")
            fout.write ("#ifndef\t__{0}_H\n".format(os.path.basename(header).upper().replace('.','_')))
            fout.write ("#define\t__{0}_H\n".format(os.path.basename(header).upper().replace('.','_')))
            fout.write ("\n")
            fout.write ("\n")
            fout.write ("#define\t{0}_NBR\t{1}\n".format(dbtype.upper(), len(generated)))
            fout.write ("#define\t{0}_INFO_NBR\t{1}\n".format(dbname.upper(), count))
            fout.write ("\n")
            fout.write ("\n")
            fout.write ("typedef struct _{0}".format (dbtype))
            fout.write ("{\n")
            fout.write ("\tchar *fname;\n")
            fout.write ("\tuint8_t* data;\n")
            fout.write ("\tsize_t* size;\n")
            fout.write ("} ")
            fout.write ("{0};\n".format (dbtype))
            fout.write ("\n")
            fout.write ("\n")
            fout.write ("typedef struct _{0}".format (dbinfo_type))
            fout.write ("{\n")
            fout.write ("\tchar     *fname;\n")
            fout.write ("\tchar     *path;\n")
            fout.write ("\tchar     *mime_type;\n")
            
            fout.write ("} ")
            fout.write ("{0};\n".format (dbinfo_type))
            fout.write ("#endif")
            fout.write ("\n")
            fout.write ("\n")
            fout.write ("\n")

def clean (path):
    data = {}
    print ("build :", path)
    with open(path) as f:
        data = json.load (f)
    
    root = ""
    if "dstdir" in data:
        root = data["dstdir"]
    
    for filter in ["*.c", "*.h"]:
        p = os.path.join(os.path.abspath(data["dstdir"]), filter)
        files = glob.glob (p, root_dir=root, recursive=True)
        for file in files:
            os.remove(file)
    
def build (path):
    data = {}
    print ("build :", path)
    with open(path) as f:
        data = json.load (f)
    
    root = ""
    if "srcdir" in data:
        root = data["srcdir"]
 
    if "f2c" in data:
        generated = []
        for filter in data["f2c"]:
            
            

            p = os.path.join(os.path.abspath(root), filter)
            print ("src filter :", filter)
            print ("src path :", p)
           
            
        
            files = glob.glob (p, root_dir=root, recursive=True)
            print ("build files :", files)
            for file in files:
                if (os.path.isfile(file)):
                    print ("build file for:", file)
                    dst = data["dstdir"] + pathtovar(file)+".c"
                    varname = pathtovar(file)
                    filename = os.path.basename(file)
                    relpath = pathtoweb(os.path.relpath(file, start = root))
                    
                    mime = mimetypes.guess_type(file)

                    print ("build file :", file, dst, filename, varname, mime)
                    file2c (file, dst, varname, filename, mime)
                    generated.append ({"filename":filename, "var":varname, "src":file, "dst":dst ,"path":relpath, "mimetype":mime})

        
        generated.sort(key=lambda filedata: filedata["filename"].lower())
        build_database (generated, data["db_header"], data["db_implement"], data["db_name"], data["db_type"], data["db_type"] + "_info", data)

if __name__ == "__main__":
    #file2c (sys.argv[1], sys.argv[2])
    
    clean (sys.argv[1])
    build (sys.argv[1])
